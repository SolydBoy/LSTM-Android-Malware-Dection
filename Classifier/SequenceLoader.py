import os
import random

import numpy as np
from keras.utils.data_utils import Sequence
import pandas as pd
from tensorflow.keras.preprocessing.sequence import pad_sequences


MALWARE_DIR = "malware"
BENIGN_DIR = "benign"


class SequenceLoader(Sequence):
    """
        Class that is used as generator by keras to load our data on the fly.
        ...
        Attributes
        ----------
        list_IDs : List[str]
            List of all the sample that we use this generator.
        labels : str
            Labels corresponding to the given samples.
        path_to_data : str
            Path to the data base.
        batch_size : int
            Batch size
        shuffle :
            If True, the data set will be shuffle on the end of each epoch.
        padding :
            Apply padding on the data.
        dim :
            Input feature dimension
        indexes :
            Dictionary that contain sample as key and labels as value
        Methods
        -------
        find_labels(self, database_path : str):
            Find the labels from the database.
        find_shape(self):
            Find the input shape of this feature set.
        on_epoch_end(self):
            Methode run by keras on the end of each epoch.
        __data_generation(self, list_IDs_temp):
            Load the asked data.
        __len__(self):
            Denotes the number of batches per epoch
         __getitem__(self, index):
             Generate one batch of data
    """

    def __init__(self, database_path, path_to_data, batch_size=32, n_classes=2, shuffle=True,
                 padding=False):
        self.list_IDs = os.listdir(path_to_data)
        self.labels = self.find_labels(database_path)
        self.path_to_data = path_to_data
        self.batch_size = batch_size
        self.n_classes = n_classes
        self.shuffle = shuffle
        self.padding = padding
        self.dim = self.find_shape()
        self.indexes = {}
        for i, element in enumerate(self.list_IDs):
            self.indexes[element] = self.labels[i]
        self.on_epoch_end()

    def find_labels(self, database_path: str):
        """
            Find the labels from the database.
            ...
            Parameters
            ----------
            database_path : str
                Path to the data base.
        """
        malware = os.listdir(f"{database_path}/{MALWARE_DIR}")
        labels = []
        for element in self.list_IDs:
            is_malware = False
            for m in malware:
                if element.split('.')[0] == m.split('.')[0]:
                    labels.append(1)
                    is_malware = True
            if not is_malware:
                labels.append(0)
        return labels

    def find_shape(self):
        """
            Find the input shape of this feature set by reading the first element given.
        """
        return pd.read_csv(f"{self.path_to_data}/{self.list_IDs[0]}").shape

    def on_epoch_end(self):
        """
            Methode run by keras on the end of each epoch.
        """
        if self.shuffle:
            random.shuffle(self.list_IDs)

    def __data_generation(self, list_IDs_temp):
        y = np.empty(self.batch_size, dtype=int)
        temp_data = []
        for i, ID in enumerate(list_IDs_temp):
            temp_data.append(pd.read_csv(f"{self.path_to_data}/{ID}"))
            y[i] = self.indexes[ID]
        if self.padding:
            X = pad_sequences(temp_data, padding="post")
        else:
            X = temp_data
        return X, y

    def __len__(self):
        return int(np.floor(len(self.list_IDs) / self.batch_size))

    def __getitem__(self, index):
        """
            Generate indexes of the batch
            ...
            Parameters
            ----------
            index : int
                Current keras step.
        """
        'Generate one batch of data'
        # Generate indexes of the batch
        indexes = self.list_IDs[index * self.batch_size:(index + 1) * self.batch_size]
        # Generate data
        X, y = self.__data_generation(indexes)

        return X, y
