import sys
import os
from typing import Dict, List, Tuple

from FeatureExtraction.Api_call_constant import API_CALL_CONSTANT
from FeatureExtraction.smali_instruction import INSTRUCTION_TYPE

INIT_ID = 'constructor'
ON_CREATE_ID = 'onCreate'
ON_START_ID = 'onStart'
ON_RESTART_ID = 'onRestart'
ON_RESUME_ID = 'onResume'
ON_PAUSE_ID = 'onPause'
ON_STOP_ID = 'onStop'
ON_DESTROY_ID = 'onDestroy'

METHOD_ID = ".method"
END_METHOD_ID = ".end method"
LINE_ID = '.line'
LOCALS_ID = '.locals'
REGISTERS_ID = '.registers'
PROLOGUE_ID = '.prologue'
PARAM_ID = '.param'
END_ID = '.end'
RESTART_ID = '.restart'
ANNOTATION_ID = '.annotation'

IGNORE_LST = [
    ANNOTATION_ID,
    LINE_ID,
    LOCALS_ID,
    REGISTERS_ID,
    PROLOGUE_ID,
    PARAM_ID,
    END_ID,
    RESTART_ID,
]

ACTIVITY_LIFECYCLE = [
    INIT_ID,
    ON_CREATE_ID,
    ON_START_ID,
    ON_RESUME_ID,
    ON_PAUSE_ID,
    ON_STOP_ID,
    ON_RESTART_ID,
    ON_DESTROY_ID,
    '.packed-switch',
]
OUIDEBUG = 0

RECEIVER_FUNCTION = [
    "abortBroadcast",
    "clearAbortBroadcast",
    "getAbortBroadcast",
    "getDebugUnregister",
    "getResultCode",
    "getResultData",
    "getResultExtras"
    "goAsync",
    "isInitialStickyBroadcast",
    "isOrderedBroadcast",
    "onReceive",
    "peekService"
    "setDebugUnregister",
    "setOrderedHint",
    "setResult",
    "setResultCode",
    "setResultData",
    "setResultExtras",
]

SERVICES_LIFECYCLE = [
    "onStartCommand",
    "onBind",
    "onCreate",
    "onDestroy",
    "stopService",
]

START_ACTIVITY_ID = "startActivity"

EXPRESSION = [
    ":goto",
    ":cond",
    ":try_start",
    ":try",
    ".catch",
    ":catch",
    ":pswitch",
    ".packed-switch",
    ".catchall",
    ":catchall",
    ":array",
    ":sswitch",
]

DEFINED_TYPE = [
    "number",
    "cond",
    "function",
    "string",
    "goto",
    "object",
    "array",
    "switch",
    "try",
]

FUNCTION_CALL_ID = [
    "invoke-virtual",
    "invoke-super",
    "invoke-direct",
    "invoke-static",
    "invoke-interface",
]

ALL_ELEMENT = list(API_CALL_CONSTANT)

ALL_INSTRUCTION = FUNCTION_CALL_ID + INSTRUCTION_TYPE


def serialize_opcode_all(opcode: str) -> List[int]:
    ins_data = [0] * (len(ALL_INSTRUCTION) + len(EXPRESSION))
    if len(opcode) != 0:
        try:
            ins_data[ALL_INSTRUCTION.index(opcode)] = 1
        except ValueError:
            if opcode[0] == ':' or opcode[0] == '.':
                splited = opcode.split('_')
                ins_data[len(ALL_INSTRUCTION) + EXPRESSION.index(splited[0])] = 1
                return ins_data
    return ins_data


def serialize_register_all(register: List[str]) -> List[int]:
    param_data = [0] * 400
    if len(register) != 0:
        for r in register:
            if r != '':
                number = r[1:]
                try:
                    if r != '' and r[0] == 'p':
                        param_data[int(number[1:])] = 1
                    else:
                        param_data[200 + int(number[1:])] = 1
                except ValueError:
                    pass
                except IndexError:
                    pass
    return param_data


def serialize_variable_all(variable: [str]) -> List[int]:
    call_data = [0] * len(API_CALL_CONSTANT)
    if variable and variable[0]:
        variable = variable[0]
        if variable != '':
            if variable[0] == '"' and variable[-1] == '"':
                try:
                    to_check = '_'.join(variable[1:-1].split('.')[-2:]).upper()
                    try:
                        call_data[ALL_ELEMENT.index(to_check)] = 1
                    except ValueError:
                        pass
                except IndexError:
                    pass
            if '(' in variable:
                class_name = variable[variable.find('>') + 1:variable.find('(')].split('/')[-1]
                try:
                    call_data[ALL_ELEMENT.index(class_name)] = 1
                except ValueError:
                    pass
    return call_data


def serialize_variable_type(variable: List[str]) -> List[int]:
    call_data = [0] * len(DEFINED_TYPE)
    if variable:
        variable = variable[0]
        if variable[0] == '"':
            call_data[DEFINED_TYPE.index("string")] = 1
        elif '(' in variable:
            call_data[DEFINED_TYPE.index("function")] = 1
        elif '/' in variable:
            call_data[DEFINED_TYPE.index("object")] = 1
        elif "goto" in variable:
            call_data[DEFINED_TYPE.index("goto")] = 1
        elif "cond" in variable:
            call_data[DEFINED_TYPE.index("cond")] = 1
        elif variable.isalnum() or variable[0] == '-':
            call_data[DEFINED_TYPE.index("number")] = 1
        elif variable[0] == '[':
            call_data[DEFINED_TYPE.index("array")] = 1
        elif "pswitch" in variable or "sswitch":
            call_data[DEFINED_TYPE.index("switch")] = 1
        elif "try" in variable:
            call_data[DEFINED_TYPE.index("try")] = 1
        else:
            if len(variable) == 1:
                print(variable)
            return []
    return call_data


def serialize_variable_only_callable(variable: str) -> List[int]:
    ins_data = [0] * (len(FUNCTION_CALL_ID))
    if variable[0]:
        variable = variable[0]
        if len(variable) == 0 or variable not in FUNCTION_CALL_ID:
            return []
        ins_data[FUNCTION_CALL_ID.index(variable)] = 1
    return ins_data


def serialize_line_only_API_and_constant(line: List[List[str]]) -> List[int]:
    call_data = serialize_variable_all(line[2])
    if 1 not in call_data:
        return []
    return call_data


def serialize_line_variable_type(line: List[List[str]]) -> List[int]:
    ins_data = serialize_opcode_all(line[0][0])
    param_data = serialize_register_all(line[1])
    call_data = serialize_variable_type(line[2])
    if not call_data:
        return []
    return ins_data + param_data + call_data


def serialize_line(line: List[List[str]]) -> List[int]:
    ins_data = serialize_opcode_all(line[0][0])
    param_data = serialize_register_all(line[1])
    call_data = serialize_variable_all(line[2])
    return ins_data + param_data + call_data


def crop_methode(id: str, data: str) -> str:
    if data.find(id) == -1:
        return ''
    crop = data[data.find(id) + len(id):]
    crop = crop[:crop.find(END_METHOD_ID)]
    crop = crop[crop.find('\n') + 1:]
    return crop


def remove_methode(id: str, data: str) -> str:
    #print(data)
    start = data.find(id)
    if start == -1:
        return data
    stop = data.find(END_METHOD_ID, start) + len(END_METHOD_ID)
    #print("-----------------------------------------------")
    #print(data[0: start:] + data[stop + 1::])
    return data[0: start:] + data[stop + 1::]


def line_filter(line: str) -> bool:
    if line == '':
        return False
    for i in IGNORE_LST:
        if i in line:
            return False
    return True


def find_last_variable_assign(var: str, lines: List[List[str]]) -> List[str]:
    for prev_line in lines:
        if ("new-instance" in prev_line[0][0] or "const-class" in prev_line[0][0] or "iget-object" in prev_line[0][0]) \
                and prev_line[1][0] == var:
            return prev_line
    return []


def find_last_intent_init(var: str, lines: List[List[str]]) -> str:
    for prev_line in lines:
        if prev_line[2]:
            function_name = prev_line[2][0][prev_line[2][0].find('>') + 1:prev_line[2][0].find('(')]
        else:
            function_name = ''
        if "invoke-direct" in prev_line[0][0] and function_name == "<init>" and prev_line[1][0] == var:
            return prev_line[1][-1]
    return ''


def find_next(split: List[List[str]], method_pool: Dict[str, str], prev_line: List[List[str]], paths_to_src: [str],
              package_name: str,
              stack: List['str']) -> []:
    function_name = '>'.join(split[2][0][1:].split('>')[1:]).split('(')[0]
    class_name = split[2][0].split('-')[0].split(';')[0].replace('/', '.')[1:]
    if function_name == START_ACTIVITY_ID:
        to_search = split[1][1]
        to_search = find_last_intent_init(to_search, prev_line[::-1])
        new_activity = find_last_variable_assign(to_search, prev_line[::-1])
        if not new_activity:
            return [], []
        callback_class_constructor = new_activity[2][0][1:].split(';')[0].replace('/', '.') + '.' + INIT_ID #
        callback_class_on_create = new_activity[2][0][1:].split(';')[0].replace('/', '.') + '.' + ON_CREATE_ID #
        instructions = []
        method = []
        new_inst, new_method = sort_method(method_pool, callback_class_constructor, paths_to_src, package_name, stack)
        instructions += new_inst
        method += new_method
        new_inst, new_method = sort_method(method_pool, callback_class_on_create, paths_to_src, package_name, stack)
        instructions += new_inst
        method += new_method
        return instructions, method
    if function_name == "<init>":
        function_name = "constructor"
    return sort_method(method_pool, class_name + '.' + function_name, paths_to_src, package_name, stack)


def find_asynchronous_method(line: List[List[str]], method_pool: Dict[str, str], lines: List[List[str]],
                             paths_to_src: [str], package_name: str, stack: List) -> []:
    function_name = line[2][0][line[2][0].find('>') + 1:line[2][0].find('(')]
    if function_name == "<init>":
        class_name = line[2][0].split(';')[0][1:]
        if "$" in class_name:
            for path in paths_to_src:
                method_name = class_name.replace('.', '/')
                file_name = path + '/' + method_name + ".smali"
                if os.path.isfile(file_name):
                    with(open(file_name, encoding="utf8")) as content:
                        data = content.read()
                        methods = get_all_class_method(data)
                        for method in methods:
                            return sort_method(method_pool, class_name + '.' + method, paths_to_src, package_name, stack)
                return [], []
    return [], []


def extract_method(method_name: str, paths_to_src: str, package_name: str):
    for path in paths_to_src:
        method_name = method_name.replace('.', '/')
        file_name = path + '/' + "/".join(method_name.split('/')[:-1]) + ".smali"
        try:
            if not os.path.isfile(file_name):
                raise FileNotFoundError
            with(open(file_name, 'r', encoding="utf8")) as content:
                data = content.read()
                method = get_all_class_method(data)
                return method[method_name.split('/')[-1]]
        except FileNotFoundError:
            continue
        except OSError:
            print(method_name)
            sys.exit(45)
        except KeyError:
            # print("METHOD NOT FOUND", end=' ')
            continue
    # print("NOT IN SCOPE", end=' ')
    return ''


def split_line(line: str) -> List[List[str]]:
    result = [[line.split(' ')[0]]]
    register = []
    var = []
    split = line.split(' ')[1:]
    try:
        if len(split) != 0 and split[0][0] == '{':
            split[0] = split[0][1:]
            split[-2] = split[-2][:-2]
        for e in split:
            if e != '' and (e[0] == 'v' or e[0] == 'p'):
                if e[-1] == ',':
                    e = e[:-1]
                register.append(e)
            elif e != '':
                var.append(e)
    except IndexError:
        return []
    result.append(register)
    result.append(var)
    return result


def sort_method(method_pool: Dict[str, str], current_method: str, paths_to_src: [str], package_name: str,
                stack: List[str]) -> [str]:
    if current_method in stack or len(stack) > 2:
        return [], []
    try:
        data = method_pool[current_method]
    except KeyError:
        data = extract_method(current_method, paths_to_src, package_name)
        if data == '':
            # print(current_method)
            return [], []
    lines = []
    method_list = [current_method]
    listener_list = []
    #print(f"Current method: {current_method}, stack len: {len(stack)}")
    stack.append(current_method)
    for line in data.split('\n'):
        line = line[4:]
        if line_filter(line):
            split = split_line(line)
            if split and split[0][0] in FUNCTION_CALL_ID:
                new_lines, methods = find_next(split, method_pool, lines, paths_to_src, package_name, stack)
                lines += new_lines
                method_list += methods
                new_listener_list, methods = find_asynchronous_method(split, method_pool, lines, paths_to_src,
                                                                      package_name, stack)
                listener_list += new_listener_list
                method_list += methods
            if split:
                lines.append(split)
    return lines + listener_list, method_list


def sort_class_instruction(class_instructions: [str], starting_points: Dict[str, str]) -> [str]:
    data = ''
    class_starting_points = []
    for e in class_instructions:
        data += '\n' + starting_points[e]
    for e in class_instructions:
        if data.count(e) == 0:
            class_starting_points.append(e)
    return class_starting_points


def create_instruction_list(starting_pool: Dict[str, str], class_name: [str], paths_to_src: [str],
                            package_name: str) -> [str]:
    sort = []
    instruction_list = []
    for i_class in class_name:
        class_starting_points = sort_class_instruction([e for e in starting_pool if i_class in e], starting_pool)
        for state in class_starting_points:
            new_ins, new_method = sort_method(starting_pool, state, paths_to_src, package_name, [])
            instruction_list += new_ins
            sort += new_method
    return instruction_list, sort


def get_all_class_method(data: str, prefix: str = "") -> Dict[str, str]:
    method = {}
    index = data.find(METHOD_ID)
    while index != -1:
        crop = data[index:]
        methode_line = crop[:crop.find('\n')]
        try:
            if methode_line.split(' ')[1].split('(')[0] == 'public' or methode_line.split(' ')[1].split('(')[
                0] == 'private' or methode_line.split(' ')[1].split('(')[0] == 'protected':
                methode_name = methode_line.split(' ')[2].split('(')[0]
            else:
                methode_name = methode_line.split(' ')[1].split('(')[0]
            method[prefix + methode_name] = crop_methode(methode_line, data)
            data = remove_methode(crop, data)
            index = data.find(METHOD_ID)
        except IndexError:
            data = remove_methode(crop, data)
            index = data.find(METHOD_ID)
    return method


def find_starting_points(paths_to_src: str, class_names: [str], package_name: str) -> Dict[str, str]:
    method_pool = {}
    parsed_class = []
    for path_to_src in paths_to_src:
        package_path = path_to_src + '/' + package_name.replace('.', '/')
        try:
            for class_name in class_names:
                file_path = package_path + '/' + class_name + '.smali'
                with(open(file_path)) as content:
                    data = content.read()
                    method_pool = {**method_pool,
                                   **get_all_class_method(data, prefix=package_name + '.' + class_name.split('.')[
                                       0] + '.')}
                    parsed_class.append(class_name)
        except FileNotFoundError:
            pass
        un_parsed_class = list(set(parsed_class) ^ set(class_names))
        for e in un_parsed_class:
            file_path = path_to_src + '/' + e.replace('.', '/') + '.smali'
            if os.path.isfile(file_path):
                with(open(file_path, encoding="utf8")) as content:
                    data = content.read()
                    method_pool = {**method_pool, **get_all_class_method(data, prefix=e + '.')}
                    parsed_class.append(e)
    return method_pool


def parse_file(class_name: [str], paths_to_src: [str], package_name: str) -> List[
    List[int]]:
    method_pool = find_starting_points(paths_to_src, class_name, package_name)
    print(method_pool)
    instruction_list, method_called = create_instruction_list(method_pool, class_name, paths_to_src, package_name)
    print(f"Parsed: {len(instruction_list)}")
    features = list(filter(lambda e: e != [], map(serialize_line, instruction_list)))
    print(f"Row size {len(features[0])} feature size {len(features)}")
    if len(instruction_list) == 0:
        sys.exit(0)
    return features
