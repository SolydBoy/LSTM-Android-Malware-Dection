import sys
import os
from typing import Dict, List, Tuple
import re

from FeatureExtraction.Api_call_constant import API_CALL_CONSTANT
from FeatureExtraction.smali_instruction import INSTRUCTION_TYPE

INIT_ID = 'constructor'
ON_CREATE_ID = 'onCreate'
ON_START_ID = 'onStart'
ON_RESTART_ID = 'onRestart'
ON_RESUME_ID = 'onResume'
ON_PAUSE_ID = 'onPause'
ON_STOP_ID = 'onStop'
ON_DESTROY_ID = 'onDestroy'

METHOD_ID = ".method"
END_METHOD_ID = ".end method"
LINE_ID = '.line'
LOCALS_ID = '.locals'
REGISTERS_ID = '.registers'
PROLOGUE_ID = '.prologue'
PARAM_ID = '.param'
END_ID = '.end'
RESTART_ID = '.restart'
ANNOTATION_ID = '.annotation'

IGNORE_LST = [
    ANNOTATION_ID,
    LINE_ID,
    LOCALS_ID,
    REGISTERS_ID,
    PROLOGUE_ID,
    PARAM_ID,
    END_ID,
    RESTART_ID,
]

ACTIVITY_LIFECYCLE = [
    INIT_ID,
    ON_CREATE_ID,
    ON_START_ID,
    ON_RESUME_ID,
    ON_PAUSE_ID,
    ON_STOP_ID,
    ON_RESTART_ID,
    ON_DESTROY_ID,
    '.packed-switch',
]

RECEIVER_FUNCTION = [
    "abortBroadcast",
    "clearAbortBroadcast",
    "getAbortBroadcast",
    "getDebugUnregister",
    "getResultCode",
    "getResultData",
    "getResultExtras"
    "goAsync",
    "isInitialStickyBroadcast",
    "isOrderedBroadcast",
    "onReceive",
    "peekService"
    "setDebugUnregister",
    "setOrderedHint",
    "setResult",
    "setResultCode",
    "setResultData",
    "setResultExtras",
]

SERVICES_LIFECYCLE = [
    "onStartCommand",
    "onBind",
    "onCreate",
    "onDestroy",
    "stopService",
]

START_ACTIVITY_ID = "startActivity"

EXPRESSION = [
    ":goto",
    ":cond",
    ":try_start",
    ":try",
    ".catch",
    ":catch",
    ":pswitch",
    ".packed-switch",
    ".catchall",
    ":catchall",
    ":array",
    ":sswitch",
]

FUNCTION_CALL_ID = [
    "invoke-virtual",
    "invoke-super",
    "invoke-direct",
    "invoke-static",
    "invoke-interface",
]

ALL_ELEMENT = list(API_CALL_CONSTANT)

ALL_INSTRUCTION = FUNCTION_CALL_ID + INSTRUCTION_TYPE


def serialize_line(line: List[str]) -> List[int]:
    ins_data = [0] * (len(ALL_INSTRUCTION) + len(EXPRESSION))
    param_data = [0] * 400
    call_data = [0] * len(API_CALL_CONSTANT)
    if len(line[0]) != 0:
        if line[0] == "aget":
            print(line)
            sys.exit(0)
        try:
            ins_data[ALL_INSTRUCTION.index(line[0])] = 1
        except ValueError:
            if line[0][0] == ':' or line[0][0] == '.':
                splited = line[0].split('_')
                ins_data[len(ALL_INSTRUCTION) + EXPRESSION.index(splited[0])] = 1
                return ins_data
            print(line[0])
            # sys.exit(84)
    if line[1] != '':
        if line[1][0] == '{':
            line[1] = line[1][1:]
            line[1] = line[1][:-1]
        numbers = line[1].replace(' ', '').split(',')
        if numbers:
            for number in numbers:
                try:
                    if number != '' and number[0] == 'p':
                        param_data[int(number[1:])] = 1
                    else:
                        param_data[200 + int(number[1:])] = 1
                except ValueError:
                    pass
    if line[2] != '':
        if line[2][0] == '"' and line[2][-1] == '"':
            try:
                to_check = '_'.join(line[2][1:-1].split('.')[-2:]).upper()
                try:
                    call_data[ALL_ELEMENT.index(to_check)] = 1
                except ValueError:
                    pass
            except IndexError:
                pass
        class_name = line[2][line[2].find('>') + 1:line[2].find('(')].split('/')[-1]
        try:
            call_data[ALL_ELEMENT.index(class_name)] = 1
        except ValueError:
            pass
    return ins_data + param_data + call_data


def crop_methode(id: str, data: str) -> str:
    if data.find(id) == -1:
        return ''
    crop = data[data.find(id) + len(id):]
    crop = crop[:crop.find(END_METHOD_ID)]
    crop = crop[crop.find('\n') + 1:]
    return crop


def remove_methode(id: str, data: str) -> str:
    start = data.find(id)
    if start == -1:
        return data
    stop = data.find(END_METHOD_ID, start) + len(END_METHOD_ID)
    return data[0: start:] + data[stop + 1::]


def line_filter(line: str) -> bool:
    if line == '':
        return False
    for i in IGNORE_LST:
        if i in line:
            return False
    return True


def find_last_variable_assign(var: str, lines: List[List[str]]) -> List[str]:
    for prev_line in lines:
        if ("new-instance" in prev_line[0] or "const-class" in prev_line[0] or "iget-object" in prev_line[0]) and \
                prev_line[1] == var:
            return prev_line
    return []


def find_last_intent_init(var: str, lines: List[List[str]]) -> str:
    for prev_line in lines:
        function_name = prev_line[2][prev_line[2].find('>') + 1:prev_line[2].find('(')]
        if "invoke-direct" in prev_line[0] and function_name == "<init>" and prev_line[1].split(',')[0][1:] == var:
            return prev_line[1].split(',')[-1][1:-1]
    return ''


def find_next(line: List, method_pool: Dict[str, str], lines: List[List[str]], paths_to_src: [str], package_name: str,
              stack: List['str']) -> []:
    function_name = line[2][line[2].find('>') + 1:line[2].find('(')]
    class_name = line[2].split(';')[0].replace('/', '.')[1:]
    if function_name == START_ACTIVITY_ID:
        to_search = line[1][line[1].find(' ') + 1:-1]
        to_search = find_last_intent_init(to_search, lines[::-1])
        new_activity = find_last_variable_assign(to_search, lines[::-1])
        if not new_activity:
            return [], []
        callback_class_constructor = new_activity[2][1:].replace('/', '.')[:-1] + '.' + INIT_ID
        callback_class_on_create = new_activity[2][1:].replace('/', '.')[:-1] + '.' + ON_CREATE_ID
        instructions = []
        method = []
        new_inst, new_method = sort_method(method_pool, callback_class_constructor, paths_to_src, package_name, stack)
        instructions += new_inst
        method += new_method
        new_inst, new_method = sort_method(method_pool, callback_class_on_create, paths_to_src, package_name, stack)
        instructions += new_inst
        method += new_method
        return instructions, method
    if function_name == "<init>":
        function_name = "constructor"
    return sort_method(method_pool, class_name + '.' + function_name, paths_to_src, package_name, stack)


def find_asynchronous_method(line: List[str], method_pool: Dict[str, str], paths_to_src: [str], lines: List[List[str]],
                             package_name: str, stack: List) -> []:
    function_name = line[2][line[2].find('>') + 1:line[2].find('(')]
    if function_name == "<init>":
        class_name = line[2].split(';')[0].split('/')[-1]
        if "$" in class_name:
            callback_methods = [k for k, v in method_pool.items() if k.startswith(class_name)]
            if not callback_methods:
                return [], []
            methods = []
            instruction = []
            for callback_method in callback_methods:
                if 'constructor' not in callback_method:
                    new_inst, new_methods = sort_method(method_pool, callback_method, paths_to_src, package_name, stack)
                    instruction += new_inst
                    methods += new_methods
            return instruction, methods
    return [], []


def extract_method(method_name: str, paths_to_src: str, package_name: str):
    print(method_name)
    print(package_name)
    print()
    sys.exit(0)
    if method_name.split('.')[0] == 'com':
        for path in paths_to_src:
            method_name = method_name.replace('.', '/')
            file_name = path + '/' + "/".join(method_name.split('/')[:-1]) + ".smali"
            try:
                with(open(file_name)) as content:
                    data = content.read()
                    method = get_all_class_method(data)
                    return method[method_name.split('/')[-1]]
            except FileNotFoundError:
                # print("FILE NOTFOUND", end=' ')
                return ''
            except KeyError:
                # print("METHOD NOT FOUND", end=' ')
                return ''
    # print("NOT IN SCOPE", end=' ')
    return ''


def sort_method(method_pool: Dict[str, str], current_method: str, paths_to_src: [str], package_name: str,
                stack: List[str]) -> [str]:
    try:
        data = method_pool[current_method]
    except KeyError:
        #data = extract_method(current_method, paths_to_src, package_name)
        data = ''
        if data == '':
            # print(current_method)
            return [], []
    lines = []
    method_list = [current_method]
    listener_list = []
    if current_method in stack:
        return [], []
    #print(f"Current method: {current_method}, stack len: {len(stack)}")
    stack.append(current_method)
    for line in data.split('\n'):
        line = line[4:]
        split = line.split(' ')
        if line_filter(line):
            split = [split[0], line[len(split[0]) + 1:-1 * len(split[-1]) - 2], split[-1]]
            if split[0] in FUNCTION_CALL_ID:
                new_lines, methods = find_next(split, method_pool, lines, paths_to_src, package_name, stack)
                lines += new_lines
                method_list += methods
                new_listener_list, methods = find_asynchronous_method(split, method_pool, lines, paths_to_src,
                                                                      package_name, stack)
                listener_list += new_listener_list
                method_list += methods
            lines.append(split)
    return lines + listener_list, method_list


def sort_class_instruction(class_instructions: [str], starting_points: Dict[str, str]) -> [str]:
    data = ''
    class_starting_points = []
    for e in class_instructions:
        data += '\n' + starting_points[e]
    for e in class_instructions:
        if data.count(e) == 0:
            class_starting_points.append(e)
    return class_starting_points


def create_instruction_list(starting_pool: Dict[str, str], class_name: [str], paths_to_src: [str],
                            package_name: str) -> [str]:
    sort = []
    instruction_list = []
    for i_class in class_name:
        class_starting_points = sort_class_instruction([e for e in starting_pool if i_class in e], starting_pool)
        for state in class_starting_points:
            new_ins, new_method = sort_method(starting_pool, state, paths_to_src, package_name, [])
            instruction_list += new_ins
            sort += new_method
    return instruction_list, sort


def get_all_class_method(data: str, prefix: str = "") -> Dict[str, str]:
    method = {}
    index = data.find(METHOD_ID)
    while index != -1:
        crop = data[index:]
        methode_line = crop[:crop.find('\n')]
        try:
            if methode_line.split(' ')[1].split('(')[0] == 'public' or methode_line.split(' ')[1].split('(')[
                0] == 'private' or methode_line.split(' ')[1].split('(')[0] == 'protected':
                methode_name = methode_line.split(' ')[2].split('(')[0]
            else:
                methode_name = methode_line.split(' ')[1].split('(')[0]
            method[prefix + methode_name] = crop_methode(methode_line, data)
            data = remove_methode(crop, data)
            index = data.find(METHOD_ID)
        except IndexError:
            data = remove_methode(crop, data)
            index = data.find(METHOD_ID)
    return method


def find_starting_points(paths_to_src: str, class_names: [str], package_name: str) -> Dict[str, str]:
    method_pool = {}
    parsed_class = []
    for path_to_src in paths_to_src:
        package_path = path_to_src + '/' + package_name.replace('.', '/')
        try:
            for class_name in class_names:
                file_path = package_path + '/' + class_name + '.smali'
                with(open(file_path)) as content:
                    data = content.read()
                    method_pool = {**method_pool,
                                   **get_all_class_method(data, prefix=package_name + '.' + class_name.split('.')[
                                       0] + '.')}
                    parsed_class.append(class_name)
        except FileNotFoundError:
            pass
        un_parsed_class = list(set(parsed_class) ^ set(class_names))
        for e in un_parsed_class:
            file_path = path_to_src + '/' + e.replace('.', '/') + '.smali'
            if os.path.isfile(file_path):
                with(open(file_path)) as content:
                    data = content.read()
                    method_pool = {**method_pool, **get_all_class_method(data, prefix=e + '.')}
                    parsed_class.append(e)
    return method_pool


def parse_file(class_name: [str], paths_to_src: [str], package_name: str, parse_uncall: bool = False) -> List[List[int]]:
    method_pool = find_starting_points(paths_to_src, class_name, package_name)
    instruction_list, method_called = create_instruction_list(method_pool, class_name, paths_to_src, package_name)
    total = 0
    for i in method_pool:
        total += len(method_pool[i])
    percent = 0
    features = list(map(serialize_line, instruction_list))
    if len(instruction_list) != 0:
        percent = (len(method_pool) / len(method_called)) * 100
    print(f"Parsed: {len(instruction_list)} out of {total}  {percent}%")
    print(f"Row size {len(features[0])}")
    return []
    if len(instruction_list) == 0:
        sys.exit(0)
    return features
