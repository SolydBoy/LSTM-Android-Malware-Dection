import sys
import os
from typing import Dict, List, Tuple

from FeatureExtraction.Api_call_constant import API_CALL_CONSTANT
from FeatureExtraction.VARIANCE_03_Feature import VARIANCE_03
from FeatureExtraction.smali_instruction import INSTRUCTION_TYPE

INIT_ID = 'constructor'
ON_CREATE_ID = 'onCreate'
ON_START_ID = 'onStart'
ON_RESTART_ID = 'onRestart'
ON_RESUME_ID = 'onResume'
ON_PAUSE_ID = 'onPause'
ON_STOP_ID = 'onStop'
ON_DESTROY_ID = 'onDestroy'

METHOD_ID = ".method"
END_METHOD_ID = ".end method"
LINE_ID = '.line'
LOCALS_ID = '.locals'
REGISTERS_ID = '.registers'
PROLOGUE_ID = '.prologue'
PARAM_ID = '.param'
END_ID = '.end'
RESTART_ID = '.restart'
ANNOTATION_ID = '.annotation'

IGNORE_LST = [
    ANNOTATION_ID,
    LINE_ID,
    LOCALS_ID,
    REGISTERS_ID,
    PROLOGUE_ID,
    PARAM_ID,
    END_ID,
    RESTART_ID,
]

ACTIVITY_LIFECYCLE = [
    INIT_ID,
    ON_CREATE_ID,
    ON_START_ID,
    ON_RESUME_ID,
    ON_PAUSE_ID,
    ON_STOP_ID,
    ON_RESTART_ID,
    ON_DESTROY_ID,
    '.packed-switch',
]
OUIDEBUG = 0

RECEIVER_FUNCTION = [
    "abortBroadcast",
    "clearAbortBroadcast",
    "getAbortBroadcast",
    "getDebugUnregister",
    "getResultCode",
    "getResultData",
    "getResultExtras"
    "goAsync",
    "isInitialStickyBroadcast",
    "isOrderedBroadcast",
    "onReceive",
    "peekService"
    "setDebugUnregister",
    "setOrderedHint",
    "setResult",
    "setResultCode",
    "setResultData",
    "setResultExtras",
]

SERVICES_LIFECYCLE = [
    "onStartCommand",
    "onBind",
    "onCreate",
    "onDestroy",
    "stopService",
]

START_ACTIVITY_ID = "startActivity"

EXPRESSION = [
    ":goto",
    ":cond",
    ":try_start",
    ":try",
    ".catch",
    ":catch",
    ":pswitch",
    ".packed-switch",
    ".catchall",
    ":catchall",
    ":array",
    ":sswitch",
]

DEFINED_TYPE = [
    "number",
    "cond",
    "function",
    "string",
    "goto",
    "object",
    "array",
    "switch",
    "try",
]

FUNCTION_CALL_ID = [
    "invoke-virtual",
    "invoke-super",
    "invoke-direct",
    "invoke-static",
    "invoke-interface",
]

ALL_ELEMENT = list(API_CALL_CONSTANT)

ALL_INSTRUCTION = FUNCTION_CALL_ID + INSTRUCTION_TYPE


def serialize_opcode_all(opcode: str) -> List[int]:
    """
    Do a one-hot embedding on the opcode.

     Parameters
        ----------
        opcode : str
            opcode.
    """
    ins_data = [0] * (len(ALL_INSTRUCTION) + len(EXPRESSION))
    if len(opcode) != 0:
        try:
            ins_data[ALL_INSTRUCTION.index(opcode)] = 1
        except ValueError:
            if opcode[0] == ':' or opcode[0] == '.':
                splited = opcode.split('_')
                ins_data[len(ALL_INSTRUCTION) + EXPRESSION.index(splited[0])] = 1
                return ins_data
    return ins_data


def serialize_register_all(register: List[str], size : int) -> List[int]:
    """
    Do a one-hot embedding on the register.

     Parameters
        ----------
        register : List[str]
            List of register to serialize.
        size:
            Sire of the output array.
    """
    param_data = [0] * size
    if len(register) != 0:
        for r in register:
            if r != '':
                number = r[1:]
                try:
                    if r != '' and r[0] == 'p':
                        param_data[int(number[1:])] = 1
                    else:
                        param_data[int(size / 2) + int(number[1:])] = 1
                except ValueError:
                    pass
                except IndexError:
                    pass
    return param_data


def serialize_variable_all(variable: List[str], feature_set) -> List[int]:
    """
    Do a one-hot embedding on the variable according to the feature_set dictionary that it receive.

     Parameters
        ----------
        variable : List[str]
            Variable to serialize.
        feature_set:
            Dictionary of all the authorized value.
    """
    call_data = [0] * len(feature_set)
    feature_set = list(feature_set)
    if variable and variable[0]:
        variable = variable[0]
        if variable != '':
            if variable[0] == '"' and variable[-1] == '"':
                try:
                    to_check = '_'.join(variable[1:-1].split('.')[-2:]).upper()
                    try:
                        call_data[feature_set.index(to_check)] = 1
                    except ValueError:
                        pass
                except IndexError:
                    pass
            if '(' in variable:
                class_name = variable[variable.find('>') + 1:variable.find('(')].split('/')[-1]
                try:
                    call_data[feature_set.index(class_name)] = 1
                except ValueError:
                    pass
    return call_data


def serialize_variable_type(variable: List[str]) -> List[int]:
    """
    Do a one-hot embedding on the variable on the type of the variable.

     Parameters
        ----------
        variable : List[str]
            Variable to serialize.
    """
    call_data = [0] * len(DEFINED_TYPE)
    if variable:
        variable = variable[0]
        if variable[0] == '"':
            call_data[DEFINED_TYPE.index("string")] = 1
        elif '(' in variable:
            call_data[DEFINED_TYPE.index("function")] = 1
        elif '/' in variable:
            call_data[DEFINED_TYPE.index("object")] = 1
        elif "goto" in variable:
            call_data[DEFINED_TYPE.index("goto")] = 1
        elif "cond" in variable:
            call_data[DEFINED_TYPE.index("cond")] = 1
        elif variable.isalnum() or variable[0] == '-':
            call_data[DEFINED_TYPE.index("number")] = 1
        elif variable[0] == '[':
            call_data[DEFINED_TYPE.index("array")] = 1
        elif "pswitch" in variable or "sswitch":
            call_data[DEFINED_TYPE.index("switch")] = 1
        elif "try" in variable:
            call_data[DEFINED_TYPE.index("try")] = 1
        else:
            if len(variable) == 1:
                print(variable)
            return []
    return call_data


def serialize_line_only_API_and_constant(line: List[List[str]]) -> List[int]:
    """
    Serialize only the line that are related to Android.

     Parameters
        ----------
        line : List[List[str]]
            Line to serialize.
    """
    call_data = serialize_variable_all(line[2], VARIANCE_03)
    if 1 in call_data:
        return call_data
    return []


def serialize_line_variable_type(line: List[List[str]]) -> List[int]:
    """
    Serialize our Typed feature set.

     Parameters
        ----------
        line : List[List[str]]
            Line to serialize.
    """
    ins_data = serialize_opcode_all(line[0][0])
    param_data = serialize_register_all(line[1], 10)
    call_data = serialize_variable_type(line[2])
    if not call_data:
        return []
    return ins_data + param_data + call_data


def serialize_reference(line: List[List[str]]) -> List[int]:
    """
    Serialize our Reference feature set.

     Parameters
        ----------
        line : List[List[str]]
            Line to serialize.
    """
    ins_data = serialize_opcode_all(line[0][0])
    param_data = serialize_register_all(line[1], 10)
    call_data = serialize_variable_all(line[2], VARIANCE_03)
    return ins_data + param_data + call_data


def serialize_model(line: List[List[str]]) -> List[int]:
    """
    Serialize our Model feature set.

     Parameters
        ----------
        line : List[List[str]]
            Line to serialize.
    """
    ins_data = serialize_opcode_all(line[0][0])
    param_data = serialize_register_all(line[1], 200)
    call_data = serialize_variable_all(line[2], INSTRUCTION_TYPE)
    return ins_data + param_data + call_data


def crop_methode(id: str, data: str) -> str:
    """
    Get a methode from the data.

     Parameters
        ----------
        id : str
            name of the methode to get.
        data : str
            Data where the method should be retrieved.
    """
    if data.find(id) == -1:
        return ''
    crop = data[data.find(id) + len(id):]
    crop = crop[:crop.find(END_METHOD_ID)]
    crop = crop[crop.find('\n') + 1:]
    return crop


def remove_methode(id: str, data: str) -> str:
    """
    Remove a methode from the data.

     Parameters
        ----------
        id : str
            name of the methode to remove.
        data : str
            Data where the methode should be removed.
    """
    # print(data)
    start = data.find(id)
    if start == -1:
        return data
    stop = data.find(END_METHOD_ID, start) + len(END_METHOD_ID)
    # print("-----------------------------------------------")
    # print(data[0: start:] + data[stop + 1::])
    return data[0: start:] + data[stop + 1::]


def line_filter(line: str) -> bool:
    """
    Filter empty line, documentation etc...

     Parameters
        ----------
        line : str
            Line to verify.
    """
    if line == '':
        return False
    for i in IGNORE_LST:
        if i in line:
            return False
    return True


def find_last_variable_assign(var: str, lines: List[List[str]]) -> List[str]:
    """
    Find the last assignation of a given register.

     Parameters
        ----------
        var : str
            Register to find.
        lines : List[List[str]]
            All the previous lines of the function.
    """
    for prev_line in lines:
        if ("new-instance" in prev_line[0][0] or "const-class" in prev_line[0][0] or "iget-object" in prev_line[0][0]) \
                and prev_line[1][0] == var:
            return prev_line
    return []


def find_last_intent_init(var: str, lines: List[List[str]]) -> str:
    """
    Find the last initialisation of a given intent.

     Parameters
        ----------
        var : str
            intent to find.
        lines : List[List[str]]
            All the previous lines of the function.
    """
    for prev_line in lines:
        if prev_line[2]:
            function_name = prev_line[2][0][prev_line[2][0].find('>') + 1:prev_line[2][0].find('(')]
        else:
            function_name = ''
        if "invoke-direct" in prev_line[0][0] and function_name == "<init>" and prev_line[1][0] == var:
            return prev_line[1][-1]
    return ''


def sort_class_instruction(class_instructions: [str], starting_points: Dict[str, str]) -> [str]:
    """
    Sort the starting point in the execution order.

     Parameters
        ----------
        class_instructions : [str]
            Class which contain the starting points.
        starting_points : Dict[str, str]
            All starting points.
    """
    data = ''
    class_starting_points = []
    for e in class_instructions:
        data += '\n' + starting_points[e]
    for e in class_instructions:
        if data.count(e) == 0:
            class_starting_points.append(e)
    return class_starting_points


def get_all_class_method(data: str, prefix: str = "") -> Dict[str, str]:
    """
    Add all the method of a given class to the method pool.

     Parameters
        ----------
        data : str
            File which contain the class.
        prefix : str
            Prefix to add to the key in the method pool.
    """
    method = {}
    index = data.find(METHOD_ID)
    while index != -1:
        crop = data[index:]
        methode_line = crop[:crop.find('\n')]
        try:
            if methode_line.split(' ')[1].split('(')[0] == 'public' or methode_line.split(' ')[1].split('(')[
                0] == 'private' or methode_line.split(' ')[1].split('(')[0] == 'protected':
                methode_name = methode_line.split(' ')[2].split('(')[0]
            else:
                methode_name = methode_line.split(' ')[1].split('(')[0]
            method[prefix + methode_name] = crop_methode(methode_line, data)
            data = remove_methode(crop, data)
            index = data.find(METHOD_ID)
        except IndexError:
            data = remove_methode(crop, data)
            index = data.find(METHOD_ID)
    return method


def extract_method(method_name: str, paths_to_src: str):
    """
    Find and extract a method.

     Parameters
        ----------
        method_name : str
            Name of the method to find.
        paths_to_src : str
            Path to all smali source code.
    """
    for path in paths_to_src:
        method_name = method_name.replace('.', '/')
        file_name = path + '/' + "/".join(method_name.split('/')[:-1]) + ".smali"
        try:
            if not os.path.isfile(file_name):
                raise FileNotFoundError
            with(open(file_name, 'r', encoding="utf8")) as content:
                data = content.read()
                method = get_all_class_method(data, prefix='.'.join(method_name.split('/')[:-1]) + '.')
                content.close()
                if method[method_name.replace('/', '.')]:
                    return method
        except FileNotFoundError:
            continue
        except OSError:
            print(method_name)
            sys.exit(45)
        except KeyError:
            # print("METHOD NOT FOUND", end=' ')
            continue
    # print("NOT IN SCOPE", end=' ')
    return {}


def split_line(line: str) -> List[List[str]]:
    """
    Split line between opcode, register and variable.

     Parameters
        ----------
        line : str
            Line to split.
    """
    result = [[line.split(' ')[0]]]
    register = []
    var = []
    split = line.split(' ')[1:]
    try:
        if len(split) != 0 and split[0][0] == '{':
            split[0] = split[0][1:]
            split[-2] = split[-2][:-2]
        for e in split:
            if e != '' and (e[0] == 'v' or e[0] == 'p'):
                if e[-1] == ',':
                    e = e[:-1]
                register.append(e)
            elif e != '':
                var.append(e)
    except IndexError:
        return []
    result.append(register)
    result.append(var)
    return result


class Smali_parser:
    """
        Wrapper extract intructions form smali file
        ...
        Attributes
        ----------
        paths_to_src : List[str]
            Path to all the smali source code dir
        class_names : List[str]
            Class names that are maybe starting points
        method_pool : Dic[str, str]
            Dictionary that contain all the already parsed methode.
        max_stack : int
            Maximum number of items allowed in the stack.
        Methods
        -------
        find_next(self, split: List[List[str]], prev_line: List[List[str]], stack: List['str']) -> []:
            Find and explore the methode that have been called.
        find_asynchronous_method(self, line: List[List[str]], stack: List) -> []:
            Find and explore the class called by the startActivity key word.
        sort_method(self, current_method: str, stack: List[str]) -> [str]:
            Extract the instruction from a methods.
        create_instruction_list(self) -> [str]:
            Start the extraction of instructions for each starting points.
        find_starting_points(self) -> Dict[str, str]:
            Find the starting points.
    """

    def __init__(self, paths_to_src, class_names, package_name, max_stack = 2):
        self.paths_to_src = paths_to_src
        self.class_names = class_names
        self.package_name = package_name
        self.method_pool = {}
        self.max_stack = max_stack

    def find_next(self, split: List[List[str]], prev_line: List[List[str]], stack: List[str]) -> []:
        """
        Find and explore the methode that have been called.

        Parameters
        ----------
        split : List[List[str]]
            Current line.
        prev_line : str
            All the previous lines of the function.
        stack : List[str]
            Current stack
        """
        function_name = '>'.join(split[2][0][1:].split('>')[1:]).split('(')[0]
        class_name = split[2][0].split('-')[0].split(';')[0].replace('/', '.')[1:]
        if function_name == START_ACTIVITY_ID:
            to_search = split[1][1]
            to_search = find_last_intent_init(to_search, prev_line[::-1])
            new_activity = find_last_variable_assign(to_search, prev_line[::-1])
            if not new_activity:
                return [], []
            callback_class_constructor = new_activity[2][0][1:].split(';')[0].replace('/', '.') + '.' + INIT_ID  #
            callback_class_on_create = new_activity[2][0][1:].split(';')[0].replace('/', '.') + '.' + ON_CREATE_ID  #
            instructions = []
            method = []
            new_inst, new_method = self.sort_method(callback_class_constructor, stack)
            instructions += new_inst
            method += new_method
            new_inst, new_method = self.sort_method(callback_class_on_create, stack)
            instructions += new_inst
            method += new_method
            return instructions, method
        if function_name == "<init>":
            function_name = "constructor"
        return self.sort_method(class_name + '.' + function_name, stack)

    def find_asynchronous_method(self, line: List[List[str]], stack: List) -> []:
        """
        Find and explore the class called by the startActivity key word.

        Parameters
        ----------
        line : List[List[str]]
            Current line.
        stack : List[str]
            Current stack
        """
        function_name = line[2][0][line[2][0].find('>') + 1:line[2][0].find('(')]
        if function_name == "<init>":
            class_name = line[2][0].split(';')[0][1:]
            if "$" in class_name:
                for path in self.paths_to_src:
                    method_name = class_name.replace('.', '/')
                    file_name = path + '/' + method_name + ".smali"
                    if os.path.isfile(file_name):
                        with(open(file_name, encoding="utf8")) as content:
                            data = content.read()
                            methods = get_all_class_method(data)
                            self.method_pool = {**self.method_pool, **methods}
                            for method in methods:
                                return self.sort_method(class_name + '.' + method, stack)
                    return [], []
        return [], []

    def sort_method(self, current_method: str, stack: List[str]) -> [str]:
        """
        Extract the instruction from a methods.

        Parameters
        ----------
        current_method : str
            Current method.
        """
        if current_method in stack or len(stack) > self.max_stack:
            return [], []
        try:
            data = self.method_pool[current_method]
        except KeyError:
            tmp_method_pool = extract_method(current_method, self.paths_to_src, self.package_name)
            if not tmp_method_pool:
                return [], []
            self.method_pool = {**self.method_pool, **tmp_method_pool}
            data = self.method_pool[current_method.replace('/', '.')]
        lines = []
        method_list = [current_method]
        listener_list = []
        stack.append(current_method)
        for line in data.split('\n'):
            line = line[4:]
            if line_filter(line):
                split = split_line(line)
                if split and split[0][0] in FUNCTION_CALL_ID:
                    new_lines, methods = self.find_next(split, lines, stack)
                    lines += new_lines
                    method_list += methods
                    new_listener_list, methods = self.find_asynchronous_method(split, stack)
                    listener_list += new_listener_list
                    method_list += methods
                if split and serialize_line_only_API_and_constant(split):
                    lines.append(split)
        return lines + listener_list, method_list

    def create_instruction_list(self) -> [str]:
        """
        Start the extraction of instructions for each starting points.
        """
        sort = []
        instruction_list = []
        for i_class in self.class_names:
            class_starting_points = sort_class_instruction([e for e in self.method_pool if i_class in e],
                                                           self.method_pool)
            for state in class_starting_points:
                new_ins, new_method = self.sort_method(state, [])
                instruction_list += new_ins
                sort += new_method
        return instruction_list, sort

    def find_starting_points(self) -> Dict[str, str]:
        """
        Find the starting points.
        """
        parsed_class = []
        for path_to_src in self.paths_to_src:
            package_path = path_to_src + '/' + self.package_name.replace('.', '/')
            try:
                for class_name in self.class_names:
                    file_path = package_path + '/' + class_name + '.smali'
                    with(open(file_path)) as content:
                        data = content.read()
                        self.method_pool = {**self.method_pool,
                                            **get_all_class_method(data,
                                                                   prefix=self.package_name + '.' +
                                                                          class_name.split('.')[
                                                                              0] + '.')}
                        parsed_class.append(class_name)
            except FileNotFoundError:
                pass
            un_parsed_class = list(set(parsed_class) ^ set(self.class_names))
            for e in un_parsed_class:
                file_path = path_to_src + '/' + e.replace('.', '/') + '.smali'
                if os.path.isfile(file_path):
                    with(open(file_path, encoding="utf8")) as content:
                        data = content.read()
                        self.method_pool = {**self.method_pool, **get_all_class_method(data, prefix=e + '.')}
                        parsed_class.append(e)
        return self.method_pool


def get_all_feature_set_representation(instruction_list: List[List[str]]) -> List[List[List[int]]]:
    """
    Return all the feature set representations from the extracted instructions.

     Parameters
        ----------
        instruction_list : List[List[str]]
            List of all the extracted methods.
    """
    all_rep = [list(filter(lambda e: e != [], map(serialize_line_variable_type, instruction_list))),
               list(filter(lambda e: e != [], map(serialize_reference, instruction_list))),
               list(filter(lambda e: e != [], map(serialize_model, instruction_list))),
               list(filter(lambda e: e != [], map(serialize_line_only_API_and_constant, instruction_list)))]
    return all_rep


def parse_file(class_name: [str], paths_to_src: [str], package_name: str) ->  List[List[List[int]]]:
    smali_parser = Smali_parser(paths_to_src, class_name, package_name)
    smali_parser.find_starting_points()
    instruction_list, method_called = smali_parser.create_instruction_list()
    print(f"{len(instruction_list)}")
    features = get_all_feature_set_representation(instruction_list)
    return features
