import os
import sys
import subprocess
import pandas as pd
from typing import Dict, Tuple, List
from tqdm import tqdm
import re
import time
import shutil

from FeatureExtraction.smali_parser import parse_file
from .resources import PERMISSIONS
from .resources import INTENTS
from .Api_call_constant import API_CALL_CONSTANT
import multiprocessing
from itertools import repeat
import csv
from pandas.core.series import Series
from pandas.core.frame import DataFrame
import zipfile

# Setup part
#
# Path to the working dir
# Exemple for window "C:/Users/Basile/Documents/GitHub/LSTM-Android-Malware-Dection"
# Exemple for linux "/home/basile_lamarque/delivery/HW/Dissertation/LSTM-Android-Malware-Dection"
#
DIR_PATH = "/home/basile_lamarque/delivery/HW/Dissertation/LSTM-Android-Malware-Dection"

# Are you using this program on windows
IS_WINDOWS = False

# True if you need to decompile the apk and false if it is already decompiled.
DECOMPILE_APK = False

FEATURE_EXTRACTION_DIR = "/FeatureExtraction"
if IS_WINDOWS:
    DEX2JAR_PATH = f"{DIR_PATH}{FEATURE_EXTRACTION_DIR}/dex-tools-2.1-SNAPSHOT/d2j-dex2jar.bat"
else:
    DEX2JAR_PATH = f"{DIR_PATH}{FEATURE_EXTRACTION_DIR}/dex-tools-2.1-SNAPSHOT/d2j-dex2jar.sh"
DEX_FILE_NAME = "classes.dex"
JAR_SRC_DEST = "/jarsrc.zip"
ANDROIDMANIFEST_PATH = "/AndroidManifest.xml"
JAR_SRC = "/jarsrc"
PACKAGE_NAME = ["<activity", "<meta-data", "<service", "<receiver", "<application"]
SQ_ORDER = ["TYPED", "REFERENCE", "MODEL", "ANDROID"]

class apktoolWrapper:
    """
        A class wrap the usage of Apktool
        ...
        Attributes
        ----------
        path_to_jar : str
            Path to the apktool dir
        jar_name : str
            Name of the apktool executable
        Methods
        -------
        extract(self, path_to_apk: str, out_dir: str = './dest'):
            Decompile an apk thank to Apktool
    """

    def __init__(self, path_to_jar: str = ".", jar_name: str = "apktool.jar"):
        self.path_to_jar = path_to_jar
        self.jar_name = jar_name

    def extract(self, path_to_apk: str, out_dir: str = './dest'):
        """
        Add a new link.
        If a link already exist, return False.

        Parameters
        ----------
        path_to_apk : str
            Path to the apk to decompile
        out_dir : str
            Path to the dir where the decompiled apk will be put.
        """
        subprocess.call(
            ["java", "-jar", self.path_to_jar + '/' + self.jar_name, "d", '-o', out_dir, path_to_apk, "--force"])


class featureExtraction:
    """
        Extract tool used to extract as well squence data and none sequence data
        ...
        Attributes
        ----------
        path_to_jar : str
            Path to the apktool dir
        jar_name : str
            Name of the apktool executable
        Methods
        -------
        extract(self, path_to_apk: str, out_dir: str = './dest'):
            Decompile an apk thank to Apktool
    """

    def __init__(self, dest):
        self.w = open(dest, "w")
        header = ["Label"] + list(API_CALL_CONSTANT.keys())
        self.writer = csv.writer(self.w)
        self.writer.writerow(header)
        self.time_stamp = time.time()
        self.dest = dest

    def __del__(self):
        self.w.close()

    @staticmethod
    def read_csv(feature_path: str) -> Tuple[DataFrame, DataFrame, Series]:
        """
            Method used to read saved feature in csv
            ...
            Parameters
            ----------
            feature_path : str
                Path to the csv to read
        """
        data = pd.read_csv(feature_path)
        data = data
        y = data['Label']
        X = data.drop('Label', axis=1)
        return data, X, y

    @staticmethod
    def reverse_engineering_jar(apk_path: str, dest: str) -> str:
        """
            Transform the class.dex into jar decompiled code
            ...
            Parameters
            ----------
            apk_path : str
                Path to the apk dir
            dest : str
                Path to the dir where to jar source will be decompiled
        """
        dir_name = dest + JAR_SRC_DEST

        with zipfile.ZipFile(apk_path, 'r') as z:
            with z.open('classes.dex') as zf, open(dest + '/classes.dex', 'wb') as f:
                shutil.copyfileobj(zf, f)
        subprocess.call([DEX2JAR_PATH, '-o', dir_name, dest + "/" + DEX_FILE_NAME, '--force'])
        with zipfile.ZipFile(dest + JAR_SRC_DEST, 'r') as zip_ref:
            zip_ref.extractall(dest + JAR_SRC)
            zip_ref.close()
        #    os.remove(dest + JAR_SRC_DEST)
        return dest + JAR_SRC

    @staticmethod
    def search(data: str, element: str) -> [str, int]:
        """
           Method used by the @find_occurrence_thread to search for occurrence in the text
            ...
            Parameters
            ----------
            data: str
                Text where we look for the occurrence.
            element: str
                Element to look for.
        """
        return [element, data.count(' ' + element)]

    @staticmethod
    def find_occurrence_thread(data: str, occurrence: Dict[str, int], frequency: bool = False) -> [[str, int]]:
        """
            Find the occurrence of a list of string in a given text but thread to search
             several occurrence at same time.
            ...
            Parameters
            ----------
            data: str
                Text where we look for the occurrence.
            occurrence: Dict[str, int]
                Dictionary of occurrence to look for. Result will be placed as value.
            frequency:
                If true the number of occurrence is return, if false return 1 if an occurrence was find and 0 if not
        """
        with multiprocessing.Pool(processes=multiprocessing.cpu_count()) as pool:
            search = pool.starmap(featureExtraction.search, list(zip(repeat(data), occurrence)))
            return search

    @staticmethod
    def find_occurrence(data: str, occurrence: Dict[str, int], frequency: bool = False) -> Dict[str, int]:
        """
            Find the occurrence of a list of string in a given text.
            ...
            Parameters
            ----------
            data: str
                Text where we look for the occurrence.
            occurrence: Dict[str, int]
                Dictionary of occurrence to look for. Result will be placed as value.
            frequency:
                If true the number of occurrence is return, if false return 1 if an occurrence was find and 0 if not.
        """
        res = occurrence
        for intent in occurrence:
            if data.find(intent) != -1 or data.find(intent.lower()) != -1:
                if frequency:
                    res[intent] += 1
                else:
                    res[intent] = 1
        return res

    @staticmethod
    def extract_manifest_features(apk_path: str) -> Tuple[List[Dict[str, int]], List[str], str]:
        """
            Extract permission, intents, class_name and package_name from the AndroidManifest
            ...
            Parameters
            ----------
            apk_path : str
                Decompiled apk path
        """
        with(open(apk_path + ANDROIDMANIFEST_PATH, "r", encoding="utf8")) as manifest:
            data = manifest.read()
            intents = featureExtraction.find_occurrence(data, INTENTS)
            permission = featureExtraction.find_occurrence(data, PERMISSIONS)
            class_name = []
            package_name = data[data.index('package="'):].split('"')[1]
            matches = re.findall(r'|'.join(PACKAGE_NAME), data, re.IGNORECASE)
            for match in matches:
                try:
                    data = data[data.index(match):]
                    sample = data[0:data.index(">")]
                    sample = sample[sample.index("android:name=\""):]
                    class_name.append(sample.split('"')[1])
                    data = data[data.index(">"):]
                except ValueError:
                    continue
            return [permission, intents], class_name, package_name

    @staticmethod
    def extract_api_constant(apk_path: str) -> [[str, int]]:
        """
            Extract Android API call and constant feature from a decompiled jar code.
            ...
            Parameters
            ----------
            apk_path: str
                Path to the apk to extract
        """
        data = ''
        for root, subdirs, files in os.walk(apk_path):
            for file in files:
                with(open(root + '/' + file, "r", errors='replace')) as content:
                    data += content.read().replace('\n', '')
        api_call_constant = featureExtraction.find_occurrence_thread(data, API_CALL_CONSTANT, True)
        return api_call_constant

    def save_feature(self, label: int, manifest_feature: [Dict[str, int]], api_constant: [[str, int]]) -> None:
        row = [label] + [item[1] for item in api_constant] + [item for sublist in
                                                              [list(item.values()) for item in manifest_feature] for
                                                              item in sublist]
        self.writer.writerow(row)

    def save_features(self, labels: [int], manifest_features: [[Dict[str, int]]],
                      api_constants: [[[str, int]]]) -> None:
        """
            Save the non sequence feature (usefull for the part 3.5.2)
            ...
            Parameters
            ----------
            labels: [int]
                List of the label of the apk
            manifest_features : [[Dict[str, int]]]
                List of all the feature extracted from the AndroidManifest for each file.
            api_constants: [[[str, int]]]
                 List of all the Android API call and constants feature extracted from the jar code for each file.
        """
        rows = []
        for label, manifest_feature, api_constant in zip(labels, manifest_features, api_constants):
            rows.append([label] + [item[1] for item in api_constant] + [item for sublist in
                                                                        [list(item.values()) for item in
                                                                         manifest_feature] for
                                                                        item in sublist])
            api_count = list(filter(lambda x: x[1] >= 1, api_constant))
            mani_count = list(filter(lambda x: manifest_feature[0][x] >= 1, manifest_feature[0]))
            print("Label: 1")
            print("Api constant: " + str(len(api_count)) + '/' + str(len(api_constant)))
            print("INTENTS features: " + str(len(list(manifest_feature[0].keys()))))
            print("Permission feature: " + str(len(mani_count)) + '/' + str(len(list(manifest_feature[1].keys()))))
        print(rows)
        self.writer.writerows(rows)
        return

    @staticmethod
    def create_feature_sequence(path_to_src: List[str], class_name: List[str], package_name: str) -> List[List[List[int]]]:
        """
            Extract squence feature from a selected apk
            ...
            Parameters
            ----------
            path_to_src : List[str]
                List of all the smali sources dir
            class_name : List[str]
                List of all the class_name that could be starting points
            package_name : str
                App package name

        """
        for i_class in class_name:
            if i_class[0] == '.':
                class_name[class_name.index(i_class)] = i_class[1:]
        return parse_file(class_name, path_to_src, package_name)

    def feature_extraction(self, apk_paths: [str], labels: [int], dest: str, apktool_bool: bool = True) -> None:
        mani = []
        api = []
        apktool = apktoolWrapper(path_to_jar='./FeatureExtraction')
        try:
            os.makedirs(dest)
        except FileExistsError:
            pass
        for path in tqdm(apk_paths):
            dir = dest + path.split('/')[-1].split('.')[0]
            if apktool_bool:
                print("Apktool")
                apktool.extract(path, dir)
            print("Extracting manifest")
            i_mani, class_name, package_name = self.extract_manifest_features(dir)
            mani.append(i_mani)
            print("Extract api call and constant")
            jar_src_path = self.reverse_engineering_jar(path, dir)
            api.append(self.extract_api_constant(jar_src_path))
        self.save_features(labels, mani, api)

    @staticmethod
    def find_source_path(dir: str):
        """
            List all the smali source dir
            ...
            Parameters
            ----------
            dir : str
                Decompiled apk path
        """
        files = os.listdir(dir)
        path_to_src = []
        for file in files:
            if os.path.isdir(dir + '/' + file) and "smali" in file:
                path_to_src.append(dir + '/' + file)
        return path_to_src

    def save_sequence_data(self, sequence: List[List[int]], apk_name: str, name: str):
        """
            Save the squence feature extracted.
            ...
            Parameters
            ----------
            sequence : List[List[int]]
                Sequence feature to save
            apk_name : str
                Name of the apk from whose features come from
            name : str
                Name of this feature representation
        """
        folder = f"{self.dest}_{name}_{self.time_stamp}/"
        if not os.path.exists(folder):
            os.makedirs(folder)
        pd.DataFrame(sequence).to_csv(f'{folder}{apk_name}.csv')

    def extract_sequence_feature(self, apk_paths: [str], dest: str, apktool_bool: bool = True):
        """
            Extract the features from each apk_paths.
            ...
            Parameters
            ----------
            apk_paths : [str]
                Path of all the apk to extract the feature
            dest : str
                Path to the dir where the feature will be saved
            apktool_bool : bool
                True if the apk need to be decompiled with Apktool
        """
        mani = []
        apktool = apktoolWrapper(path_to_jar=DIR_PATH + FEATURE_EXTRACTION_DIR)
        try:
            os.makedirs(dest)
        except FileExistsError:
            pass
        if apktool_bool:
            for path in apk_paths:
                dir = dest + path.split('/')[-1].split('.')[0]
                apktool.extract(path, dir)
        for path in tqdm(apk_paths):
            dir = dest + path.split('/')[-1].split('.')[0]
            paths_to_sources = self.find_source_path(dir)
            i_mani, class_name, package_name = self.extract_manifest_features(dir)
            mani.append(i_mani)
            sq = self.create_feature_sequence(paths_to_sources, class_name, package_name)
            for i, e in enumerate(sq):
                self.save_sequence_data(e, path.split('/')[-1][:-4], SQ_ORDER[i])
        return
