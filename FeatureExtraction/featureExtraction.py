import os
import sys
import subprocess
from subprocess import check_output
import pandas as pd
from typing import Dict, Tuple, List
from tqdm import tqdm
import re
import time
import shutil

from FeatureExtraction.smali_parser import parse_file
from .resources import PERMISSIONS
from .resources import INTENTS
from .Api_call_constant import API_CALL_CONSTANT
import multiprocessing
from itertools import zip_longest
from itertools import repeat
import csv
from pandas.core.series import Series
from pandas.core.frame import DataFrame
import zipfile

DEBUG_PATH = "../DataBase/benign/00753DD9164683E9094D162FD1A50F5878C1D47E212F8079055345CE2379208F.apk"

DIR_LINUX = './FeatureExtraction'
DIR_WIN = '/FeatureExtraction'
DEX_FILE_NAME = "classes.dex"
JAR_SRC_DEST = "/jarsrc.zip"
DEX2JAR_PATH_LINUX = DIR_LINUX + "/dex-tools-2.1-SNAPSHOT/d2j-dex2jar.sh"
DEX2JAR_PATH_WIN = "C:/Users/Basile/Documents/GitHub/LSTM-Android-Malware-Dection/FeatureExtraction/dex-tools-2.1-SNAPSHOT/d2j-dex2jar.bat"
DEX2SMALI_PATH = DIR_LINUX + "/dex-tools-2.1-SNAPSHOT/d2j-dex2smali.sh"
FERNFLOWER_PATH = DIR_WIN + "/../../tools/fernflower.jar"
ANDROIDMANIFEST_PATH = "/AndroidManifest.xml"
AXMLPRINTER_PATH = DIR_WIN + '/AXMLPrinter2.jar'
JAR_SRC = "/jarsrc"
SMALI_SRC = "/smalisrc"
PACKAGE_NAME = ["<activity", "<meta-data", "<service", "<receiver", "<application"]


def grouper(iterable, n, fillvalue=None):
    args = [iter(iterable)] * n
    return list(zip_longest(*args, fillvalue=fillvalue))


class apktoolWrapper:
    def __init__(self, path_to_jar: str = ".", jar_name: str = "apktool.jar"):
        self.path_to_jar = path_to_jar
        self.jar_name = jar_name

    def extract(self, path_to_apk: str, out_dir: str = './dest'):
        subprocess.call(
            ["java", "-jar", self.path_to_jar + '/' + self.jar_name, "d", '-o', out_dir, path_to_apk, "--force"])


class featureExtraction:

    def __init__(self, dest):
        self.w = open(dest, "w")
        header = ["Label"] + list(API_CALL_CONSTANT.keys())
        print("Label: 1")
        print("Api constant: " + str(len(list(API_CALL_CONSTANT.keys()))))
        print("INTENTS features: " + str(len(list(INTENTS.keys()))))
        print("Permission feature: " + str(len(list(PERMISSIONS.keys()))))
        self.writer = csv.writer(self.w)
        self.writer.writerow(header)
        self.time_stamp = time.time()

    def __del__(self):
        self.w.close()

    @staticmethod
    def read_csv(feature_path: str) -> Tuple[DataFrame, DataFrame, Series]:
        data = pd.read_csv(feature_path)
        data = data
        y = data['Label']
        X = data.drop('Label', axis=1)
        return data, X, y

    @staticmethod
    def binary_xml_to_xml(path: str):
        readable_data = check_output(["java", "-jar", AXMLPRINTER_PATH, path])
        with(open(path, "w")) as content:
            content.write(readable_data.decode("utf-8"))

    @staticmethod
    def apk_unzip(apk_path: str, destination: str = './') -> str:
        dir_name = apk_path.split('/')[-1].split('.')[0]
        with zipfile.ZipFile(apk_path, 'r') as zip_ref:
            zip_ref.extractall(destination + dir_name)
            try:
                with open(destination + dir_name + ANDROIDMANIFEST_PATH) as AndroidManifestData:
                    c = AndroidManifestData.read(1)
                    if c != '<':
                        featureExtraction.binary_xml_to_xml(destination + dir_name + ANDROIDMANIFEST_PATH)
            except UnicodeDecodeError:
                featureExtraction.binary_xml_to_xml(destination + dir_name + ANDROIDMANIFEST_PATH)
            return destination + dir_name

    @staticmethod
    def reverse_engineering_jar(apk_path: str, dest: str) -> str:
        print(apk_path)
        dir_name = dest + JAR_SRC_DEST

        with zipfile.ZipFile(apk_path, 'r') as z:
            with z.open('classes.dex') as zf, open(dest + '/classes.dex', 'wb') as f:
                shutil.copyfileobj(zf, f)
        subprocess.call([DEX2JAR_PATH_LINUX, '-o', dir_name, dest + "/" + DEX_FILE_NAME, '--force'])
        with zipfile.ZipFile(dest + JAR_SRC_DEST, 'r') as zip_ref:
            zip_ref.extractall(dest + JAR_SRC)
            zip_ref.close()
        #    os.remove(dest + JAR_SRC_DEST)
        return dest + JAR_SRC

    @staticmethod
    def reverse_engineering_smali(apk_path: str) -> str:
        dir_name = apk_path + SMALI_SRC
        subprocess.call([DEX2SMALI_PATH, '-o', dir_name, apk_path + "/" + DEX_FILE_NAME, '--force'])
        return apk_path + SMALI_SRC

    @staticmethod
    def search(data: str, element: str) -> [str, int]:
        return [element, data.count(' ' + element)]

    @staticmethod
    def find_occurrence_thread(data: str, occurrence: Dict[str, int], frequency: bool = False) -> [[str, int]]:
        with multiprocessing.Pool(processes=multiprocessing.cpu_count()) as pool:
            search = pool.starmap(featureExtraction.search, list(zip(repeat(data), occurrence)))
            return search

    @staticmethod
    def find_occurrence(data: str, occurrence: Dict[str, int], frequency: bool = False) -> Dict[str, int]:
        res = occurrence
        for intent in occurrence:
            if data.find(intent) != -1 or data.find(intent.lower()) != -1:
                if frequency:
                    res[intent] += 1
                else:
                    res[intent] = 1
        return res

    @staticmethod
    def extract_manifest_features(apk_path: str) -> Tuple[List[Dict[str, int]], List[str], str]:
        with(open(apk_path + ANDROIDMANIFEST_PATH, "r", encoding="utf8")) as manifest:
            data = manifest.read()
            intents = featureExtraction.find_occurrence(data, INTENTS)
            permission = featureExtraction.find_occurrence(data, PERMISSIONS)
            class_name = []
            package_name = data[data.index('package="'):].split('"')[1]
            matches = re.findall(r'|'.join(PACKAGE_NAME), data, re.IGNORECASE)
            for match in matches:
                try:
                    data = data[data.index(match):]
                    sample = data[0:data.index(">")]
                    sample = sample[sample.index("android:name=\""):]
                    class_name.append(sample.split('"')[1])
                    data = data[data.index(">"):]
                except ValueError:
                    continue
            return [permission, intents], class_name, package_name

    @staticmethod
    def extract_api_constant(apk_path: str) -> [[str, int]]:
        data = ''
        for root, subdirs, files in os.walk(apk_path):
            for file in files:
                with(open(root + '/' + file, "r", errors='replace')) as content:
                    data += content.read().replace('\n', '')
        api_call_constant = featureExtraction.find_occurrence_thread(data, API_CALL_CONSTANT, True)
        return api_call_constant

    def save_feature(self, label: int, manifest_feature: [Dict[str, int]], api_constant: [[str, int]]) -> None:
        row = [label] + [item[1] for item in api_constant] + [item for sublist in
                                                              [list(item.values()) for item in manifest_feature] for
                                                              item in sublist]
        self.writer.writerow(row)

    def save_features(self, labels: [int], manifest_features: [[Dict[str, int]]],
                      api_constants: [[[str, int]]]) -> None:
        rows = []
        for label, manifest_feature, api_constant in zip(labels, manifest_features, api_constants):
            rows.append([label] + [item[1] for item in api_constant] + [item for sublist in
                                                                        [list(item.values()) for item in
                                                                         manifest_feature] for
                                                                        item in sublist])
            api_count = list(filter(lambda x: x[1] >= 1, api_constant))
            mani_count = list(filter(lambda x: manifest_feature[0][x] >= 1, manifest_feature[0]))
            print("Label: 1")
            print("Api constant: " + str(len(api_count)) + '/' + str(len(api_constant)))
            print("INTENTS features: " + str(len(list(manifest_feature[0].keys()))))
            print("Permission feature: " + str(len(mani_count)) + '/' + str(len(list(manifest_feature[1].keys()))))
        print(rows)
        self.writer.writerows(rows)
        return

    def create_feature_sequence(self, path_to_src: [str], class_name: List[str], package_name: str,
                                inlcude_extra: bool = False) -> List[List[int]]:
        if not inlcude_extra:
            class_name = list(filter(lambda x: x.count('.') < 2, class_name))
        for i_class in class_name:
            if i_class[0] == '.':
                class_name[class_name.index(i_class)] = i_class[1:]
        return parse_file(class_name, path_to_src, package_name)

    def feature_extraction(self, apk_paths: [str], labels: [int], dest: str, apktool_bool: bool = True) -> None:
        mani = []
        api = []
        apktool = apktoolWrapper(path_to_jar='./FeatureExtraction')
        try:
            os.makedirs(dest)
        except FileExistsError:
            pass
        for path in tqdm(apk_paths):
            dir = dest + path.split('/')[-1].split('.')[0]
            if apktool_bool:
                print("Apktool")
                apktool.extract(path, dir)
            print("Extracting manifest")
            i_mani, class_name, package_name = self.extract_manifest_features(dir)
            mani.append(i_mani)
            print("Extract api call and constant")
            jar_src_path = self.reverse_engineering_jar(path, dir)
            api.append(self.extract_api_constant(jar_src_path))
        self.save_features(labels, mani, api)

    def find_source_path(self, dir: str):
        files = os.listdir(dir)
        path_to_src = []
        for file in files:
            if os.path.isdir(dir + '/' + file) and "smali" in file:
                path_to_src.append(dir + '/' + file)
        return path_to_src

    def save_sequence_data(self, sequence: List[List[int]], label: int):
        perm = 'a+'
        if not os.path.exists(f'D:/sequence_Android_maxrec1_{self.time_stamp}.csv'):
            perm = 'w'
        with open(f'D:/sequence_Android_maxrec1_{self.time_stamp}.csv', perm, newline='') as f:
            writer = csv.writer(f)
            for e in tqdm(sequence):
                writer.writerow([e])
            writer.writerow([label])
            f.close()

    def extract_sequence_feature(self, apk_paths: [str], labels: [int], dest: str, apktool_bool: bool = True):
        mani = []
        apktool = apktoolWrapper(path_to_jar='./FeatureExtraction')
        try:
            os.makedirs(dest)
        except FileExistsError:
            pass
        if apktool_bool:
            for path in apk_paths:
                dir = dest + path.split('/')[-1].split('.')[0]
                apktool.extract(path, dir)
        i = 0
        for path in tqdm(apk_paths):
            print(path)
            dir = dest + path.split('/')[-1].split('.')[0]
            paths_to_sources = self.find_source_path(dir)
            i_mani, class_name, package_name = self.extract_manifest_features(dir)
            mani.append(i_mani)
            sequence = self.create_feature_sequence(paths_to_sources, class_name, package_name, True)
            #self.save_sequence_data(sequence, labels[i])
            i += 1
        return


if __name__ == "__main__":
    a = featureExtraction("test.csv")
    path_benign = os.listdir("../DataBase/benign")
    path_benign = list(map(lambda x: "../DataBase/benign/" + x, path_benign))
    path_malware = os.listdir("../DataBase/malware/")
    path_malware = list(map(lambda x: "../DataBase/malware/" + x, path_malware))
    labels = [0] * len(path_benign) + [1] * len(path_malware)
    a.feature_extraction(path_benign + path_malware, labels, "./dest/")
    # a.feature_extraction(["../DataBase/benign/00753DD9164683E9094D162FD1A50F5878C1D47E212F8079055345CE2379208F.apk"], [1], "./dest/")
